\section{实验过程记录}

\subsection{问题1: 处理数据冒险}
\textbf{问题描述：} 需解决可能存在的数据冒险，指的是在流水线处理器中，由于当前指令可能依赖于前一条指令的结果，但前一条指令的结果尚未写回到寄存器堆中，导致后续指令读取到错误值的情况。

\textbf{解决方案：}
\begin{enumerate}
    \item \textbf{数据前推（Forwarding）：} 通过在执行阶段将计算结果直接传递给下一条指令的执行阶段，避免等待写回阶段。实现逻辑是判断当前输入 ALU 的地址是否与其他指令在执行阶段要写入寄存器堆的地址相同，如果是，就通过多路选择器将其他指令的结果输入到 ALU 中。
    \item \textbf{流水线暂停（Pipeline Stall）：} 在某些情况下，数据前推无法解决所有数据冒险问题，需要暂停流水线等待数据读取后再继续执行。在 decode 阶段判断是否存在数据冲突，若存在则设置暂停信号，暂停流水线的执行，直到数据冲突问题解决。以上功能的代码被写入 hazard 模块，由 datapath 调用。
\end{enumerate}

\subsection{问题2: 处理控制冒险}
\textbf{问题描述：} 控制冒险是由分支指令引起的冒险，分支指令在第4阶段才决定是否跳转，导致前三条指令已进入流水线执行的问题。

\textbf{解决方案：}
\begin{enumerate}
    \item \textbf{提前判断分支（Branch Prediction）：} 在 decode 阶段提前判断分支是否会发生，避免等待第4阶段才知道是否跳转。实现逻辑是在 regfile 输出后添加判断相等的模块，提前判断分支情况。
    \item \textbf{控制冒险前推（Control Hazard Forwarding）：} 类似于数据前推，在 execute 阶段判断当前输入寄存器的地址是否与其他指令要写入的地址相同，若相同则将其他指令的结果直接传递给 ALU 执行。同时，根据控制冒险引入的数据冲突问题，需要增加数据前推和流水线暂停模块。以上功能的代码被写入 hazard 模块，由 datapath 调用。
\end{enumerate}

\subsection{问题3: 流水线的实现}
\textbf{问题描述：} 在 datapath 中正确调用 flopr、floprc、flopenrc 三个模块以实现流水线。

\textbf{解决方案：}
根据指导书中的图示，给 FETCH、DECODE、EXECUTE、MEMORY 和 WRITEBACK 这五个流水线阶段相应的输入输出调用合适的触发器。
\begin{itemize}
    \item \textbf{flopr：} 适合用于普通的寄存器，只有时钟和复位信号，在流水线 CPU 中，可以用于存储一些不需要重置或清除的数据，如写回阶段的结果数据。
    \item \textbf{floprc：} 除了时钟和复位信号外，增加了清除信号，适合用于在流水线中需要对某些寄存器进行清除操作的情况，例如在控制冒险时需要清除部分寄存器的数据。
    \item \textbf{flopenrc：} 在 floprc 的基础上增加了使能信号，适合需要根据外部使能信号来控制数据写入的情况，例如在数据冒险时需要根据数据前推信号来控制数据的写入。根据各个阶段的需求，调用不同触发器，例如上述描述的各种冒险会出现的位置，添加相应端口调用 floprc 或 flopenrc，来灵活地控制数据的传递和处理。
\end{itemize}

\subsection{问题4: 端口适配}
\textbf{问题描述：} 使其余模块端口适配上层文件。

\textbf{解决方案：} 由于实现流水线功能和处理冒险，产生新的端口，修改上层文件的端口调用以实现正确调用。

\subsection{问题5: 仿真调试}
\textbf{问题描述：} 调用 top 模块进行仿真。

\textbf{解决方案：} 根据已给出的仿真文件对实现的流水线单周期 CPU 进行仿真，通过仿真图和控制台打印的输出判断仿真是否成功。